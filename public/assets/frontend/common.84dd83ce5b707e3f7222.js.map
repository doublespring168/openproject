{"version":3,"sources":["./node_modules/codemirror/mode/stex/stex.js","./node_modules/codemirror/mode/haskell/haskell.js","./node_modules/codemirror/mode/python/python.js","./node_modules/codemirror/mode/handlebars/handlebars.js","./node_modules/codemirror/addon/mode/multiplex.js","./node_modules/codemirror/mode/sass/sass.js","./node_modules/codemirror/addon/mode/simple.js","./node_modules/codemirror/mode/ruby/ruby.js","./node_modules/codemirror/addon/mode/overlay.js","./node_modules/codemirror/mode/coffeescript/coffeescript.js","./node_modules/codemirror/mode/yaml/yaml.js"],"names":["CodeMirror","defineMode","_config","parserConfig","pushCommand","state","command","cmdState","push","peekCommand","length","addPluginPattern","pluginName","cmdStyle","styles","this","name","bracketNo","style","argument","styleIdentifier","openBracket","closeBracket","plugins","setState","f","normal","source","plug","match","cmdName","current","slice","beginParams","inMathMode","ch","next","skipToEnd","test","eatWhile","context","i","getMostPowerful","endModeSeq","eatSpace","peek","eat","pop","popCommand","startState","copyState","s","token","stream","blankLine","lineComment","defineMIME","mod","modeConfig","switchState","smallRE","largeRE","digitRE","hexitRE","octitRE","idRE","symbolRE","specialRE","whiteCharRE","t","ncomment","type","nest","currNest","eol","stringLiteral","stringGap","wellKnownWords","wkw","setType","arguments","override","overrideKeywords","word","hasOwnProperty","w","blockCommentStart","blockCommentEnd","wordRegexp","words","RegExp","join","str","wordOperators","commonKeywords","commonBuiltins","top","scopes","registerHelper","concat","conf","parserConf","delimiters","singleDelimiters","operators","singleOperators","doubleOperators","doubleDelimiters","tripleDelimiters","splice","hangingIndent","indentUnit","myKeywords","myBuiltins","undefined","extra_keywords","extra_builtins","py3","version","Number","identifiers","stringPrefixes","keywords","builtins","tokenBase","sol","lastToken","indent","indentation","scopeOffset","offset","lineOffset","pushPyScope","dedent","errorToken","tokenBaseInner","floatLiteral","intLiteral","toLowerCase","indexOf","tokenize","delimiter","tokenOuter","charAt","substr","singleline","tokenNestedExpr","depth","inner","tokenString","singleLineStringErrors","isString","formatStringFactory","tokenStringFactory","align","indented","tokenLexer","beginningOfLine","lambda","delimiter_index","column","pushBracketScope","basecolumn","addErr","textAfter","Pass","scope","closing","electricInput","closeBrackets","triples","fold","split","defineSimpleMode","start","regex","handlebars_raw","handlebars","dash_comment","comment","meta","config","getMode","base","multiplexingMode","open","close","mode","parseDelimiters","outer","others","Array","prototype","call","string","pattern","from","returnEnd","found","m","exec","index","innerActive","curInner","oldContent","pos","delimStyle","innerToken","innerStyle","cutOff","Infinity","other","outerIndent","possibleOuterIndent","outerToken","line","electricChars","innerMode","cssMode","mimeModes","propertyKeywords","colorKeywords","valueKeywords","fontProperties","keywordsRegexp","opRegexp","pseudoElementsRegexp","isEndLine","urlTokens","tokenizer","buildStringTokenizer","multiLine","skipTo","quote","greedy","stringTokenizer","nextChar","peekChar","previousChar","cursorHalf","buildInterpolationTokenizer","currentTokenizer","indentCount","currentOffset","unshift","shift","prevProp","prop","definedVars","definedMixins","withCurrentIndent","newScopes","content","ensureState","states","Error","toRegex","val","caret","flags","ignoreCase","String","Rule","data","apply","replace","result","asToken","tokenFunction","pending","pend","text","local","end","tok","endToken","localState","endScan","curState","rule","matches","stack","enterLocalMode","j","backUp","cmp","a","b","props","spec","pers","persistent","p","persistentStates","lState","forceEnd","indentFunction","dontIndentStates","arr","rules","scan","dedentIfLineStart","simpleMode","states_","hasIndentation","list","orig","wordObj","o","e","curPunc","indentWords","dedentWords","opening","chain","newtok","readBlockComment","phrase","mayIndent","readQuoted","escaped","regexpAhead","embed","delim","propertyIsEnumerable","varList","lastTok","more","tokenBaseUntilBrace","tokenBaseOnce","alreadyCalled","unescaped","prev","continuedLine","kwtype","thisTok","firstChar","ct","closed","overlayMode","overlay","combine","basePos","baseCur","overlayPos","overlayCur","streamSeen","Math","min","combineTokens","baseToken","overlayToken","atProp","indentKeywords","regexPrefixes","constants","longComment","tokenFactory","outclass","alignOffset","_indent","matched","fillAlign","closer","closes","keywordRegex","esc","literal","keyCol","pair","pairStart","inlinePairs","inlineList"],"mappings":"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","file":"common.84dd83ce5b707e3f7222.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/*\n * Author: Constantin Jucovschi (c.jucovschi@jacobs-university.de)\n * Licence: MIT\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"stex\", function(_config, parserConfig) {\n    \"use strict\";\n\n    function pushCommand(state, command) {\n      state.cmdState.push(command);\n    }\n\n    function peekCommand(state) {\n      if (state.cmdState.length > 0) {\n        return state.cmdState[state.cmdState.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    function popCommand(state) {\n      var plug = state.cmdState.pop();\n      if (plug) {\n        plug.closeBracket();\n      }\n    }\n\n    // returns the non-default plugin closest to the end of the list\n    function getMostPowerful(state) {\n      var context = state.cmdState;\n      for (var i = context.length - 1; i >= 0; i--) {\n        var plug = context[i];\n        if (plug.name == \"DEFAULT\") {\n          continue;\n        }\n        return plug;\n      }\n      return { styleIdentifier: function() { return null; } };\n    }\n\n    function addPluginPattern(pluginName, cmdStyle, styles) {\n      return function () {\n        this.name = pluginName;\n        this.bracketNo = 0;\n        this.style = cmdStyle;\n        this.styles = styles;\n        this.argument = null;   // \\begin and \\end have arguments that follow. These are stored in the plugin\n\n        this.styleIdentifier = function() {\n          return this.styles[this.bracketNo - 1] || null;\n        };\n        this.openBracket = function() {\n          this.bracketNo++;\n          return \"bracket\";\n        };\n        this.closeBracket = function() {};\n      };\n    }\n\n    var plugins = {};\n\n    plugins[\"importmodule\"] = addPluginPattern(\"importmodule\", \"tag\", [\"string\", \"builtin\"]);\n    plugins[\"documentclass\"] = addPluginPattern(\"documentclass\", \"tag\", [\"\", \"atom\"]);\n    plugins[\"usepackage\"] = addPluginPattern(\"usepackage\", \"tag\", [\"atom\"]);\n    plugins[\"begin\"] = addPluginPattern(\"begin\", \"tag\", [\"atom\"]);\n    plugins[\"end\"] = addPluginPattern(\"end\", \"tag\", [\"atom\"]);\n\n    plugins[\"label\"    ] = addPluginPattern(\"label\"    , \"tag\", [\"atom\"]);\n    plugins[\"ref\"      ] = addPluginPattern(\"ref\"      , \"tag\", [\"atom\"]);\n    plugins[\"eqref\"    ] = addPluginPattern(\"eqref\"    , \"tag\", [\"atom\"]);\n    plugins[\"cite\"     ] = addPluginPattern(\"cite\"     , \"tag\", [\"atom\"]);\n    plugins[\"bibitem\"  ] = addPluginPattern(\"bibitem\"  , \"tag\", [\"atom\"]);\n    plugins[\"Bibitem\"  ] = addPluginPattern(\"Bibitem\"  , \"tag\", [\"atom\"]);\n    plugins[\"RBibitem\" ] = addPluginPattern(\"RBibitem\" , \"tag\", [\"atom\"]);\n\n    plugins[\"DEFAULT\"] = function () {\n      this.name = \"DEFAULT\";\n      this.style = \"tag\";\n\n      this.styleIdentifier = this.openBracket = this.closeBracket = function() {};\n    };\n\n    function setState(state, f) {\n      state.f = f;\n    }\n\n    // called when in a normal (no environment) context\n    function normal(source, state) {\n      var plug;\n      // Do we look like '\\command' ?  If so, attempt to apply the plugin 'command'\n      if (source.match(/^\\\\[a-zA-Z@]+/)) {\n        var cmdName = source.current().slice(1);\n        plug = plugins[cmdName] || plugins[\"DEFAULT\"];\n        plug = new plug();\n        pushCommand(state, plug);\n        setState(state, beginParams);\n        return plug.style;\n      }\n\n      // escape characters\n      if (source.match(/^\\\\[$&%#{}_]/)) {\n        return \"tag\";\n      }\n\n      // white space control characters\n      if (source.match(/^\\\\[,;!\\/\\\\]/)) {\n        return \"tag\";\n      }\n\n      // find if we're starting various math modes\n      if (source.match(\"\\\\[\")) {\n        setState(state, function(source, state){ return inMathMode(source, state, \"\\\\]\"); });\n        return \"keyword\";\n      }\n      if (source.match(\"\\\\(\")) {\n        setState(state, function(source, state){ return inMathMode(source, state, \"\\\\)\"); });\n        return \"keyword\";\n      }\n      if (source.match(\"$$\")) {\n        setState(state, function(source, state){ return inMathMode(source, state, \"$$\"); });\n        return \"keyword\";\n      }\n      if (source.match(\"$\")) {\n        setState(state, function(source, state){ return inMathMode(source, state, \"$\"); });\n        return \"keyword\";\n      }\n\n      var ch = source.next();\n      if (ch == \"%\") {\n        source.skipToEnd();\n        return \"comment\";\n      } else if (ch == '}' || ch == ']') {\n        plug = peekCommand(state);\n        if (plug) {\n          plug.closeBracket(ch);\n          setState(state, beginParams);\n        } else {\n          return \"error\";\n        }\n        return \"bracket\";\n      } else if (ch == '{' || ch == '[') {\n        plug = plugins[\"DEFAULT\"];\n        plug = new plug();\n        pushCommand(state, plug);\n        return \"bracket\";\n      } else if (/\\d/.test(ch)) {\n        source.eatWhile(/[\\w.%]/);\n        return \"atom\";\n      } else {\n        source.eatWhile(/[\\w\\-_]/);\n        plug = getMostPowerful(state);\n        if (plug.name == 'begin') {\n          plug.argument = source.current();\n        }\n        return plug.styleIdentifier();\n      }\n    }\n\n    function inMathMode(source, state, endModeSeq) {\n      if (source.eatSpace()) {\n        return null;\n      }\n      if (endModeSeq && source.match(endModeSeq)) {\n        setState(state, normal);\n        return \"keyword\";\n      }\n      if (source.match(/^\\\\[a-zA-Z@]+/)) {\n        return \"tag\";\n      }\n      if (source.match(/^[a-zA-Z]+/)) {\n        return \"variable-2\";\n      }\n      // escape characters\n      if (source.match(/^\\\\[$&%#{}_]/)) {\n        return \"tag\";\n      }\n      // white space control characters\n      if (source.match(/^\\\\[,;!\\/]/)) {\n        return \"tag\";\n      }\n      // special math-mode characters\n      if (source.match(/^[\\^_&]/)) {\n        return \"tag\";\n      }\n      // non-special characters\n      if (source.match(/^[+\\-<>|=,\\/@!*:;'\"`~#?]/)) {\n        return null;\n      }\n      if (source.match(/^(\\d+\\.\\d*|\\d*\\.\\d+|\\d+)/)) {\n        return \"number\";\n      }\n      var ch = source.next();\n      if (ch == \"{\" || ch == \"}\" || ch == \"[\" || ch == \"]\" || ch == \"(\" || ch == \")\") {\n        return \"bracket\";\n      }\n\n      if (ch == \"%\") {\n        source.skipToEnd();\n        return \"comment\";\n      }\n      return \"error\";\n    }\n\n    function beginParams(source, state) {\n      var ch = source.peek(), lastPlug;\n      if (ch == '{' || ch == '[') {\n        lastPlug = peekCommand(state);\n        lastPlug.openBracket(ch);\n        source.eat(ch);\n        setState(state, normal);\n        return \"bracket\";\n      }\n      if (/[ \\t\\r]/.test(ch)) {\n        source.eat(ch);\n        return null;\n      }\n      setState(state, normal);\n      popCommand(state);\n\n      return normal(source, state);\n    }\n\n    return {\n      startState: function() {\n        var f = parserConfig.inMathMode ? function(source, state){ return inMathMode(source, state); } : normal;\n        return {\n          cmdState: [],\n          f: f\n        };\n      },\n      copyState: function(s) {\n        return {\n          cmdState: s.cmdState.slice(),\n          f: s.f\n        };\n      },\n      token: function(stream, state) {\n        return state.f(stream, state);\n      },\n      blankLine: function(state) {\n        state.f = normal;\n        state.cmdState.length = 0;\n      },\n      lineComment: \"%\"\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-stex\", \"stex\");\n  CodeMirror.defineMIME(\"text/x-latex\", \"stex\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"haskell\", function(_config, modeConfig) {\n\n  function switchState(source, setState, f) {\n    setState(f);\n    return f(source, setState);\n  }\n\n  // These should all be Unicode extended, as per the Haskell 2010 report\n  var smallRE = /[a-z_]/;\n  var largeRE = /[A-Z]/;\n  var digitRE = /\\d/;\n  var hexitRE = /[0-9A-Fa-f]/;\n  var octitRE = /[0-7]/;\n  var idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\n  var symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\n  var specialRE = /[(),;[\\]`{}]/;\n  var whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\n  function normal(source, setState) {\n    if (source.eatWhile(whiteCharRE)) {\n      return null;\n    }\n\n    var ch = source.next();\n    if (specialRE.test(ch)) {\n      if (ch == '{' && source.eat('-')) {\n        var t = \"comment\";\n        if (source.eat('#')) {\n          t = \"meta\";\n        }\n        return switchState(source, setState, ncomment(t, 1));\n      }\n      return null;\n    }\n\n    if (ch == '\\'') {\n      if (source.eat('\\\\')) {\n        source.next();  // should handle other escapes here\n      }\n      else {\n        source.next();\n      }\n      if (source.eat('\\'')) {\n        return \"string\";\n      }\n      return \"string error\";\n    }\n\n    if (ch == '\"') {\n      return switchState(source, setState, stringLiteral);\n    }\n\n    if (largeRE.test(ch)) {\n      source.eatWhile(idRE);\n      if (source.eat('.')) {\n        return \"qualifier\";\n      }\n      return \"variable-2\";\n    }\n\n    if (smallRE.test(ch)) {\n      source.eatWhile(idRE);\n      return \"variable\";\n    }\n\n    if (digitRE.test(ch)) {\n      if (ch == '0') {\n        if (source.eat(/[xX]/)) {\n          source.eatWhile(hexitRE); // should require at least 1\n          return \"integer\";\n        }\n        if (source.eat(/[oO]/)) {\n          source.eatWhile(octitRE); // should require at least 1\n          return \"number\";\n        }\n      }\n      source.eatWhile(digitRE);\n      var t = \"number\";\n      if (source.match(/^\\.\\d+/)) {\n        t = \"number\";\n      }\n      if (source.eat(/[eE]/)) {\n        t = \"number\";\n        source.eat(/[-+]/);\n        source.eatWhile(digitRE); // should require at least 1\n      }\n      return t;\n    }\n\n    if (ch == \".\" && source.eat(\".\"))\n      return \"keyword\";\n\n    if (symbolRE.test(ch)) {\n      if (ch == '-' && source.eat(/-/)) {\n        source.eatWhile(/-/);\n        if (!source.eat(symbolRE)) {\n          source.skipToEnd();\n          return \"comment\";\n        }\n      }\n      var t = \"variable\";\n      if (ch == ':') {\n        t = \"variable-2\";\n      }\n      source.eatWhile(symbolRE);\n      return t;\n    }\n\n    return \"error\";\n  }\n\n  function ncomment(type, nest) {\n    if (nest == 0) {\n      return normal;\n    }\n    return function(source, setState) {\n      var currNest = nest;\n      while (!source.eol()) {\n        var ch = source.next();\n        if (ch == '{' && source.eat('-')) {\n          ++currNest;\n        }\n        else if (ch == '-' && source.eat('}')) {\n          --currNest;\n          if (currNest == 0) {\n            setState(normal);\n            return type;\n          }\n        }\n      }\n      setState(ncomment(type, currNest));\n      return type;\n    };\n  }\n\n  function stringLiteral(source, setState) {\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == '\"') {\n        setState(normal);\n        return \"string\";\n      }\n      if (ch == '\\\\') {\n        if (source.eol() || source.eat(whiteCharRE)) {\n          setState(stringGap);\n          return \"string\";\n        }\n        if (source.eat('&')) {\n        }\n        else {\n          source.next(); // should handle other escapes here\n        }\n      }\n    }\n    setState(normal);\n    return \"string error\";\n  }\n\n  function stringGap(source, setState) {\n    if (source.eat('\\\\')) {\n      return switchState(source, setState, stringLiteral);\n    }\n    source.next();\n    setState(normal);\n    return \"error\";\n  }\n\n\n  var wellKnownWords = (function() {\n    var wkw = {};\n    function setType(t) {\n      return function () {\n        for (var i = 0; i < arguments.length; i++)\n          wkw[arguments[i]] = t;\n      };\n    }\n\n    setType(\"keyword\")(\n      \"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\",\n      \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\",\n      \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n\n    setType(\"keyword\")(\n      \"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n\n    setType(\"builtin\")(\n      \"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\",\n      \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\",\n      \"*>\", \"**\");\n\n    setType(\"builtin\")(\n      \"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\",\n      \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\",\n      \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\",\n      \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\",\n      \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\",\n      \"String\", \"True\");\n\n    setType(\"builtin\")(\n      \"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\",\n      \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\",\n      \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\",\n      \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\",\n      \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\",\n      \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\",\n      \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\",\n      \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\",\n      \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\",\n      \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\",\n      \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\",\n      \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\",\n      \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\",\n      \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\",\n      \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\",\n      \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\",\n      \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\",\n      \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\",\n      \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\",\n      \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\",\n      \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\",\n      \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\",\n      \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\",\n      \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\",\n      \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\",\n      \"zip3\", \"zipWith\", \"zipWith3\");\n\n    var override = modeConfig.overrideKeywords;\n    if (override) for (var word in override) if (override.hasOwnProperty(word))\n      wkw[word] = override[word];\n\n    return wkw;\n  })();\n\n\n\n  return {\n    startState: function ()  { return { f: normal }; },\n    copyState:  function (s) { return { f: s.f }; },\n\n    token: function(stream, state) {\n      var t = state.f(stream, function(s) { state.f = s; });\n      var w = stream.current();\n      return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n    },\n\n    blockCommentStart: \"{-\",\n    blockCommentEnd: \"-}\",\n    lineComment: \"--\"\n  };\n\n});\n\nCodeMirror.defineMIME(\"text/x-haskell\", \"haskell\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n                        \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n                        \"for\", \"from\", \"global\", \"if\", \"import\",\n                        \"lambda\", \"pass\", \"raise\", \"return\",\n                        \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n                        \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n                        \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n                        \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n                        \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n                        \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n                        \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n                        \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n                        \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n                        \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n                        \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function(conf, parserConf) {\n    var ERRORCLASS = \"error\";\n\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n    //               (Backwards-compatiblity with old, cumbersome config system)\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,\n                     parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/]\n    for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n\n    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined)\n      myKeywords = myKeywords.concat(parserConf.extra_keywords);\n\n    if (parserConf.extra_builtins != undefined)\n      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3)\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(fr))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                                      \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                                      \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins);\n\n    // tokenizers\n    function tokenBase(stream, state) {\n      var sol = stream.sol() && state.lastToken != \"\\\\\"\n      if (sol) state.indent = stream.indentation()\n      // Handle scope changes\n      if (sol && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset)\n            pushPyScope(state);\n          else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\")\n            state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state))\n            style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state) {\n      if (stream.eatSpace()) return null;\n\n      // Handle Comments\n      if (stream.match(/^#.*/)) return \"comment\";\n\n      // Handle Number Literals\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false;\n        // Floats\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n        if (stream.match(/^[\\d_]+\\.\\d*/)) { floatLiteral = true; }\n        if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        }\n        // Integers\n        var intLiteral = false;\n        // Hex\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n        // Binary\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n        // Octal\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n        // Decimal\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i);\n          // TODO - Can you have imaginary longs?\n          intLiteral = true;\n        }\n        // Zero by itself with no other piece of number.\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      }\n\n      // Handle Strings\n      if (stream.match(stringPrefixes)) {\n        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n        if (!isFmtString) {\n          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        } else {\n          state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      for (var i = 0; i < operators.length; i++)\n        if (stream.match(operators[i])) return \"operator\"\n\n      if (stream.match(delimiters)) return \"punctuation\";\n\n      if (state.lastToken == \".\" && stream.match(identifiers))\n        return \"property\";\n\n      if (stream.match(keywords) || stream.match(wordOperators))\n        return \"keyword\";\n\n      if (stream.match(builtins))\n        return \"builtin\";\n\n      if (stream.match(/^(self|cls)\\b/))\n        return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\")\n          return \"def\";\n        return \"variable\";\n      }\n\n      // Handle non-detected items\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function formatStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenNestedExpr(depth) {\n        return function(stream, state) {\n          var inner = tokenBaseInner(stream, state)\n          if (inner == \"punctuation\") {\n            if (stream.current() == \"{\") {\n              state.tokenize = tokenNestedExpr(depth + 1)\n            } else if (stream.current() == \"}\") {\n              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1)\n              else state.tokenize = tokenString\n            }\n          }\n          return inner\n        }\n      }\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else if (stream.match('{{')) {\n            // ignore {{ in f-str\n            return OUTCLASS;\n          } else if (stream.match('{', false)) {\n            // switch to nested mode\n            state.tokenize = tokenNestedExpr(0)\n            if (stream.current()) return OUTCLASS;\n            else return state.tokenize(stream, state)\n          } else if (stream.match('}}')) {\n            return OUTCLASS;\n          } else if (stream.match('}')) {\n            // single } in f-string is an error\n            return ERRORCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function tokenStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") state.scopes.pop()\n      state.scopes.push({offset: top(state).offset + conf.indentUnit,\n                         type: \"py\",\n                         align: null})\n    }\n\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^([\\s\\[\\{\\(]|#.*)*$/, false) ? null : stream.column() + 1\n      state.scopes.push({offset: state.indent + hangingIndent,\n                         type: type,\n                         align: align})\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) state.beginningOfLine = true;\n\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      // Handle decorators\n      if (state.beginningOfLine && current == \"@\")\n        return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n\n      if ((style == \"variable\" || style == \"builtin\")\n          && state.lastToken == \"meta\")\n        style = \"meta\";\n\n      // Handle scope changes.\n      if (current == \"pass\" || current == \"return\")\n        state.dedent += 1;\n\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\")\n        pushPyScope(state);\n\n      if (current.length == 1 && !/string|comment/.test(style)) {\n        var delimiter_index = \"[({\".indexOf(current);\n        if (delimiter_index != -1)\n          pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\n        delimiter_index = \"])}\".indexOf(current);\n        if (delimiter_index != -1) {\n          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent\n          else return ERRORCLASS;\n        }\n      }\n      if (state.dedent > 0 && stream.eol() && top(state).type == \"py\") {\n        if (state.scopes.length > 1) state.scopes.pop();\n        state.dedent -= 1;\n      }\n\n      return style;\n    }\n\n    var external = {\n      startState: function(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{offset: basecolumn || 0, type: \"py\", align: null}],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n\n      token: function(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n\n        if (style && style != \"comment\")\n          state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n\n        if (stream.eol() && state.lambda)\n          state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n\n      indent: function(state, textAfter) {\n        if (state.tokenize != tokenBase)\n          return state.tokenize.isString ? CodeMirror.Pass : 0;\n\n        var scope = top(state), closing = scope.type == textAfter.charAt(0)\n        if (scope.align != null)\n          return scope.align - (closing ? 1 : 0)\n        else\n          return scope.offset - (closing ? hangingIndent : 0)\n      },\n\n      electricInput: /^\\s*[\\}\\]\\)]$/,\n      closeBrackets: {triples: \"'\\\"\"},\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function(str) { return str.split(\" \"); };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \"+\n                          \"extern gil include nogil property public \"+\n                          \"readonly struct union DEF IF ELIF ELSE\")\n  });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../../addon/mode/simple\"), require(\"../../addon/mode/multiplex\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../../addon/mode/simple\", \"../../addon/mode/multiplex\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineSimpleMode(\"handlebars-tags\", {\n    start: [\n      { regex: /\\{\\{\\{/, push: \"handlebars_raw\", token: \"tag\" },\n      { regex: /\\{\\{!--/, push: \"dash_comment\", token: \"comment\" },\n      { regex: /\\{\\{!/,   push: \"comment\", token: \"comment\" },\n      { regex: /\\{\\{/,    push: \"handlebars\", token: \"tag\" }\n    ],\n    handlebars_raw: [\n      { regex: /\\}\\}\\}/, pop: true, token: \"tag\" },\n    ],\n    handlebars: [\n      { regex: /\\}\\}/, pop: true, token: \"tag\" },\n\n      // Double and single quotes\n      { regex: /\"(?:[^\\\\\"]|\\\\.)*\"?/, token: \"string\" },\n      { regex: /'(?:[^\\\\']|\\\\.)*'?/, token: \"string\" },\n\n      // Handlebars keywords\n      { regex: />|[#\\/]([A-Za-z_]\\w*)/, token: \"keyword\" },\n      { regex: /(?:else|this)\\b/, token: \"keyword\" },\n\n      // Numeral\n      { regex: /\\d+/i, token: \"number\" },\n\n      // Atoms like = and .\n      { regex: /=|~|@|true|false/, token: \"atom\" },\n\n      // Paths\n      { regex: /(?:\\.\\.\\/)*(?:[A-Za-z_][\\w\\.]*)+/, token: \"variable-2\" }\n    ],\n    dash_comment: [\n      { regex: /--\\}\\}/, pop: true, token: \"comment\" },\n\n      // Commented code\n      { regex: /./, token: \"comment\"}\n    ],\n    comment: [\n      { regex: /\\}\\}/, pop: true, token: \"comment\" },\n      { regex: /./, token: \"comment\" }\n    ],\n    meta: {\n      blockCommentStart: \"{{--\",\n      blockCommentEnd: \"--}}\"\n    }\n  });\n\n  CodeMirror.defineMode(\"handlebars\", function(config, parserConfig) {\n    var handlebars = CodeMirror.getMode(config, \"handlebars-tags\");\n    if (!parserConfig || !parserConfig.base) return handlebars;\n    return CodeMirror.multiplexingMode(\n      CodeMirror.getMode(config, parserConfig.base),\n      {open: \"{{\", close: \"}}\", mode: handlebars, parseDelimiters: true}\n    );\n  });\n\n  CodeMirror.defineMIME(\"text/x-handlebars-template\", \"handlebars\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.multiplexingMode = function(outer /*, others */) {\n  // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects\n  var others = Array.prototype.slice.call(arguments, 1);\n\n  function indexOf(string, pattern, from, returnEnd) {\n    if (typeof pattern == \"string\") {\n      var found = string.indexOf(pattern, from);\n      return returnEnd && found > -1 ? found + pattern.length : found;\n    }\n    var m = pattern.exec(from ? string.slice(from) : string);\n    return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n  }\n\n  return {\n    startState: function() {\n      return {\n        outer: CodeMirror.startState(outer),\n        innerActive: null,\n        inner: null\n      };\n    },\n\n    copyState: function(state) {\n      return {\n        outer: CodeMirror.copyState(outer, state.outer),\n        innerActive: state.innerActive,\n        inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)\n      };\n    },\n\n    token: function(stream, state) {\n      if (!state.innerActive) {\n        var cutOff = Infinity, oldContent = stream.string;\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          var found = indexOf(oldContent, other.open, stream.pos);\n          if (found == stream.pos) {\n            if (!other.parseDelimiters) stream.match(other.open);\n            state.innerActive = other;\n\n            // Get the outer indent, making sure to handle CodeMirror.Pass\n            var outerIndent = 0;\n            if (outer.indent) {\n              var possibleOuterIndent = outer.indent(state.outer, \"\", \"\");\n              if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;\n            }\n\n            state.inner = CodeMirror.startState(other.mode, outerIndent);\n            return other.delimStyle && (other.delimStyle + \" \" + other.delimStyle + \"-open\");\n          } else if (found != -1 && found < cutOff) {\n            cutOff = found;\n          }\n        }\n        if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n        var outerToken = outer.token(stream, state.outer);\n        if (cutOff != Infinity) stream.string = oldContent;\n        return outerToken;\n      } else {\n        var curInner = state.innerActive, oldContent = stream.string;\n        if (!curInner.close && stream.sol()) {\n          state.innerActive = state.inner = null;\n          return this.token(stream, state);\n        }\n        var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;\n        if (found == stream.pos && !curInner.parseDelimiters) {\n          stream.match(curInner.close);\n          state.innerActive = state.inner = null;\n          return curInner.delimStyle && (curInner.delimStyle + \" \" + curInner.delimStyle + \"-close\");\n        }\n        if (found > -1) stream.string = oldContent.slice(0, found);\n        var innerToken = curInner.mode.token(stream, state.inner);\n        if (found > -1) stream.string = oldContent;\n\n        if (found == stream.pos && curInner.parseDelimiters)\n          state.innerActive = state.inner = null;\n\n        if (curInner.innerStyle) {\n          if (innerToken) innerToken = innerToken + \" \" + curInner.innerStyle;\n          else innerToken = curInner.innerStyle;\n        }\n\n        return innerToken;\n      }\n    },\n\n    indent: function(state, textAfter, line) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (!mode.indent) return CodeMirror.Pass;\n      return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);\n    },\n\n    blankLine: function(state) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (mode.blankLine) {\n        mode.blankLine(state.innerActive ? state.inner : state.outer);\n      }\n      if (!state.innerActive) {\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          if (other.open === \"\\n\") {\n            state.innerActive = other;\n            state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, \"\", \"\") : 0);\n          }\n        }\n      } else if (state.innerActive.close === \"\\n\") {\n        state.innerActive = state.inner = null;\n      }\n    },\n\n    electricChars: outer.electricChars,\n\n    innerMode: function(state) {\n      return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: state.outer, mode: outer};\n    }\n  };\n};\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../css/css\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"sass\", function(config) {\n  var cssMode = CodeMirror.mimeModes[\"text/css\"];\n  var propertyKeywords = cssMode.propertyKeywords || {},\n      colorKeywords = cssMode.colorKeywords || {},\n      valueKeywords = cssMode.valueKeywords || {},\n      fontProperties = cssMode.fontProperties || {};\n\n  function tokenRegexp(words) {\n    return new RegExp(\"^\" + words.join(\"|\"));\n  }\n\n  var keywords = [\"true\", \"false\", \"null\", \"auto\"];\n  var keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\n\n  var operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\",\n                   \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\",\"\\\\{\",\"\\\\}\",\":\"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\n\n  var word;\n\n  function isEndLine(stream) {\n    return !stream.peek() || stream.match(/\\s+$/, false);\n  }\n\n  function urlTokens(stream, state) {\n    var ch = stream.peek();\n\n    if (ch === \")\") {\n      stream.next();\n      state.tokenizer = tokenBase;\n      return \"operator\";\n    } else if (ch === \"(\") {\n      stream.next();\n      stream.eatSpace();\n\n      return \"operator\";\n    } else if (ch === \"'\" || ch === '\"') {\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return \"string\";\n    } else {\n      state.tokenizer = buildStringTokenizer(\")\", false);\n      return \"string\";\n    }\n  }\n  function comment(indentation, multiLine) {\n    return function(stream, state) {\n      if (stream.sol() && stream.indentation() <= indentation) {\n        state.tokenizer = tokenBase;\n        return tokenBase(stream, state);\n      }\n\n      if (multiLine && stream.skipTo(\"*/\")) {\n        stream.next();\n        stream.next();\n        state.tokenizer = tokenBase;\n      } else {\n        stream.skipToEnd();\n      }\n\n      return \"comment\";\n    };\n  }\n\n  function buildStringTokenizer(quote, greedy) {\n    if (greedy == null) { greedy = true; }\n\n    function stringTokenizer(stream, state) {\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== \"\\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== \"\\\\\"));\n\n      if (endingString) {\n        if (nextChar !== quote && greedy) { stream.next(); }\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        state.tokenizer = tokenBase;\n        return \"string\";\n      } else if (nextChar === \"#\" && peekChar === \"{\") {\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return \"operator\";\n      } else {\n        return \"string\";\n      }\n    }\n\n    return stringTokenizer;\n  }\n\n  function buildInterpolationTokenizer(currentTokenizer) {\n    return function(stream, state) {\n      if (stream.peek() === \"}\") {\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return \"operator\";\n      } else {\n        return tokenBase(stream, state);\n      }\n    };\n  }\n\n  function indent(state) {\n    if (state.indentCount == 0) {\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  }\n\n  function dedent(state) {\n    if (state.scopes.length == 1) return;\n\n    state.scopes.shift();\n  }\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek();\n\n    // Comment\n    if (stream.match(\"/*\")) {\n      state.tokenizer = comment(stream.indentation(), true);\n      return state.tokenizer(stream, state);\n    }\n    if (stream.match(\"//\")) {\n      state.tokenizer = comment(stream.indentation(), false);\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match(\"#{\")) {\n      state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return \"operator\";\n    }\n\n    // Strings\n    if (ch === '\"' || ch === \"'\") {\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return \"string\";\n    }\n\n    if(!state.cursorHalf){// state.cursorHalf === 0\n    // first half i.e. before : for key-value pairs\n    // including selectors\n\n      if (ch === \"-\") {\n        if (stream.match(/^-\\w+-/)) {\n          return \"meta\";\n        }\n      }\n\n      if (ch === \".\") {\n        stream.next();\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"qualifier\";\n        } else if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if (ch === \"#\") {\n        stream.next();\n        // ID selectors\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"builtin\";\n        }\n        if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"variable-2\";\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/))\n        return \"number\";\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/))\n        return \"unit\";\n\n      if (stream.match(keywordsRegexp))\n        return \"keyword\";\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        return \"atom\";\n      }\n\n      if (ch === \"=\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^=[\\w-]+/)) {\n          indent(state);\n          return \"meta\";\n        }\n      }\n\n      if (ch === \"+\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^\\+[\\w-]+/)){\n          return \"variable-3\";\n        }\n      }\n\n      if(ch === \"@\"){\n        if(stream.match(/@extend/)){\n          if(!stream.match(/\\s*[\\w]/))\n            dedent(state);\n        }\n      }\n\n\n      // Indent Directives\n      if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n        indent(state);\n        return \"def\";\n      }\n\n      // Other Directives\n      if (ch === \"@\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"def\";\n      }\n\n      if (stream.eatWhile(/[\\w-]/)){\n        if(stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/,false)){\n          word = stream.current().toLowerCase();\n          var prop = state.prevProp + \"-\" + word;\n          if (propertyKeywords.hasOwnProperty(prop)) {\n            return \"property\";\n          } else if (propertyKeywords.hasOwnProperty(word)) {\n            state.prevProp = word;\n            return \"property\";\n          } else if (fontProperties.hasOwnProperty(word)) {\n            return \"property\";\n          }\n          return \"tag\";\n        }\n        else if(stream.match(/ *:/,false)){\n          indent(state);\n          state.cursorHalf = 1;\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        }\n        else if(stream.match(/ *,/,false)){\n          return \"tag\";\n        }\n        else{\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if(ch === \":\"){\n        if (stream.match(pseudoElementsRegexp)){ // could be a pseudo-element\n          return \"variable-3\";\n        }\n        stream.next();\n        state.cursorHalf=1;\n        return \"operator\";\n      }\n\n    } // cursorHalf===0 ends here\n    else{\n\n      if (ch === \"#\") {\n        stream.next();\n        // Hex numbers\n        if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"number\";\n        }\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"number\";\n      }\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"unit\";\n      }\n\n      if (stream.match(keywordsRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"keyword\";\n      }\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"atom\";\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"variable-2\";\n      }\n\n      // bang character for !important, !default, etc.\n      if (ch === \"!\") {\n        stream.next();\n        state.cursorHalf = 0;\n        return stream.match(/^[\\w]+/) ? \"keyword\": \"operator\";\n      }\n\n      if (stream.match(opRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"operator\";\n      }\n\n      // attributes\n      if (stream.eatWhile(/[\\w-]/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        word = stream.current().toLowerCase();\n        if (valueKeywords.hasOwnProperty(word)) {\n          return \"atom\";\n        } else if (colorKeywords.hasOwnProperty(word)) {\n          return \"keyword\";\n        } else if (propertyKeywords.hasOwnProperty(word)) {\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        } else {\n          return \"tag\";\n        }\n      }\n\n      //stream.eatSpace();\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n        return null;\n      }\n\n    } // else ends here\n\n    if (stream.match(opRegexp))\n      return \"operator\";\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  }\n\n  function tokenLexer(stream, state) {\n    if (stream.sol()) state.indentCount = 0;\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === \"@return\" || current === \"}\"){\n      dedent(state);\n    }\n\n    if (style !== null) {\n      var startOfToken = stream.pos - current.length;\n\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++) {\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent)\n          newScopes.push(scope);\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  }\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: \"sass\"}],\n        indentCount: 0,\n        cursorHalf: 0,  // cursor half tells us if cursor lies after (1)\n                        // or before (0) colon (well... more or less)\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    }\n  };\n}, \"css\");\n\nCodeMirror.defineMIME(\"text/x-sass\", \"sass\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineSimpleMode = function(name, states) {\n    CodeMirror.defineMode(name, function(config) {\n      return CodeMirror.simpleMode(config, states);\n    });\n  };\n\n  CodeMirror.simpleMode = function(config, states) {\n    ensureState(states, \"start\");\n    var states_ = {}, meta = states.meta || {}, hasIndentation = false;\n    for (var state in states) if (state != meta && states.hasOwnProperty(state)) {\n      var list = states_[state] = [], orig = states[state];\n      for (var i = 0; i < orig.length; i++) {\n        var data = orig[i];\n        list.push(new Rule(data, states));\n        if (data.indent || data.dedent) hasIndentation = true;\n      }\n    }\n    var mode = {\n      startState: function() {\n        return {state: \"start\", pending: null,\n                local: null, localState: null,\n                indent: hasIndentation ? [] : null};\n      },\n      copyState: function(state) {\n        var s = {state: state.state, pending: state.pending,\n                 local: state.local, localState: null,\n                 indent: state.indent && state.indent.slice(0)};\n        if (state.localState)\n          s.localState = CodeMirror.copyState(state.local.mode, state.localState);\n        if (state.stack)\n          s.stack = state.stack.slice(0);\n        for (var pers = state.persistentStates; pers; pers = pers.next)\n          s.persistentStates = {mode: pers.mode,\n                                spec: pers.spec,\n                                state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),\n                                next: s.persistentStates};\n        return s;\n      },\n      token: tokenFunction(states_, config),\n      innerMode: function(state) { return state.local && {mode: state.local.mode, state: state.localState}; },\n      indent: indentFunction(states_, meta)\n    };\n    if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))\n      mode[prop] = meta[prop];\n    return mode;\n  };\n\n  function ensureState(states, name) {\n    if (!states.hasOwnProperty(name))\n      throw new Error(\"Undefined state \" + name + \" in simple mode\");\n  }\n\n  function toRegex(val, caret) {\n    if (!val) return /(?:)/;\n    var flags = \"\";\n    if (val instanceof RegExp) {\n      if (val.ignoreCase) flags = \"i\";\n      val = val.source;\n    } else {\n      val = String(val);\n    }\n    return new RegExp((caret === false ? \"\" : \"^\") + \"(?:\" + val + \")\", flags);\n  }\n\n  function asToken(val) {\n    if (!val) return null;\n    if (val.apply) return val\n    if (typeof val == \"string\") return val.replace(/\\./g, \" \");\n    var result = [];\n    for (var i = 0; i < val.length; i++)\n      result.push(val[i] && val[i].replace(/\\./g, \" \"));\n    return result;\n  }\n\n  function Rule(data, states) {\n    if (data.next || data.push) ensureState(states, data.next || data.push);\n    this.regex = toRegex(data.regex);\n    this.token = asToken(data.token);\n    this.data = data;\n  }\n\n  function tokenFunction(states, config) {\n    return function(stream, state) {\n      if (state.pending) {\n        var pend = state.pending.shift();\n        if (state.pending.length == 0) state.pending = null;\n        stream.pos += pend.text.length;\n        return pend.token;\n      }\n\n      if (state.local) {\n        if (state.local.end && stream.match(state.local.end)) {\n          var tok = state.local.endToken || null;\n          state.local = state.localState = null;\n          return tok;\n        } else {\n          var tok = state.local.mode.token(stream, state.localState), m;\n          if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))\n            stream.pos = stream.start + m.index;\n          return tok;\n        }\n      }\n\n      var curState = states[state.state];\n      for (var i = 0; i < curState.length; i++) {\n        var rule = curState[i];\n        var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);\n        if (matches) {\n          if (rule.data.next) {\n            state.state = rule.data.next;\n          } else if (rule.data.push) {\n            (state.stack || (state.stack = [])).push(state.state);\n            state.state = rule.data.push;\n          } else if (rule.data.pop && state.stack && state.stack.length) {\n            state.state = state.stack.pop();\n          }\n\n          if (rule.data.mode)\n            enterLocalMode(config, state, rule.data.mode, rule.token);\n          if (rule.data.indent)\n            state.indent.push(stream.indentation() + config.indentUnit);\n          if (rule.data.dedent)\n            state.indent.pop();\n          var token = rule.token\n          if (token && token.apply) token = token(matches)\n          if (matches.length > 2 && rule.token && typeof rule.token != \"string\") {\n            state.pending = [];\n            for (var j = 2; j < matches.length; j++)\n              if (matches[j])\n                state.pending.push({text: matches[j], token: rule.token[j - 1]});\n            stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));\n            return token[0];\n          } else if (token && token.join) {\n            return token[0];\n          } else {\n            return token;\n          }\n        }\n      }\n      stream.next();\n      return null;\n    };\n  }\n\n  function cmp(a, b) {\n    if (a === b) return true;\n    if (!a || typeof a != \"object\" || !b || typeof b != \"object\") return false;\n    var props = 0;\n    for (var prop in a) if (a.hasOwnProperty(prop)) {\n      if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;\n      props++;\n    }\n    for (var prop in b) if (b.hasOwnProperty(prop)) props--;\n    return props == 0;\n  }\n\n  function enterLocalMode(config, state, spec, token) {\n    var pers;\n    if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next)\n      if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;\n    var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec);\n    var lState = pers ? pers.state : CodeMirror.startState(mode);\n    if (spec.persistent && !pers)\n      state.persistentStates = {mode: mode, spec: spec.spec, state: lState, next: state.persistentStates};\n\n    state.localState = lState;\n    state.local = {mode: mode,\n                   end: spec.end && toRegex(spec.end),\n                   endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),\n                   endToken: token && token.join ? token[token.length - 1] : token};\n  }\n\n  function indexOf(val, arr) {\n    for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;\n  }\n\n  function indentFunction(states, meta) {\n    return function(state, textAfter, line) {\n      if (state.local && state.local.mode.indent)\n        return state.local.mode.indent(state.localState, textAfter, line);\n      if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)\n        return CodeMirror.Pass;\n\n      var pos = state.indent.length - 1, rules = states[state.state];\n      scan: for (;;) {\n        for (var i = 0; i < rules.length; i++) {\n          var rule = rules[i];\n          if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {\n            var m = rule.regex.exec(textAfter);\n            if (m && m[0]) {\n              pos--;\n              if (rule.next || rule.push) rules = states[rule.next || rule.push];\n              textAfter = textAfter.slice(m[0].length);\n              continue scan;\n            }\n          }\n        }\n        break;\n      }\n      return pos < 0 ? 0 : state.indent[pos];\n    };\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"ruby\", function(config) {\n  function wordObj(words) {\n    var o = {};\n    for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;\n    return o;\n  }\n  var keywords = wordObj([\n    \"alias\", \"and\", \"BEGIN\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"defined?\", \"do\", \"else\",\n    \"elsif\", \"END\", \"end\", \"ensure\", \"false\", \"for\", \"if\", \"in\", \"module\", \"next\", \"not\", \"or\",\n    \"redo\", \"rescue\", \"retry\", \"return\", \"self\", \"super\", \"then\", \"true\", \"undef\", \"unless\",\n    \"until\", \"when\", \"while\", \"yield\", \"nil\", \"raise\", \"throw\", \"catch\", \"fail\", \"loop\", \"callcc\",\n    \"caller\", \"lambda\", \"proc\", \"public\", \"protected\", \"private\", \"require\", \"load\",\n    \"require_relative\", \"extend\", \"autoload\", \"__END__\", \"__FILE__\", \"__LINE__\", \"__dir__\"\n  ]);\n  var indentWords = wordObj([\"def\", \"class\", \"case\", \"for\", \"while\", \"until\", \"module\", \"then\",\n                             \"catch\", \"loop\", \"proc\", \"begin\"]);\n  var dedentWords = wordObj([\"end\", \"until\"]);\n  var opening = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\"};\n  var closing = {\"]\": \"[\", \"}\": \"{\", \")\": \"(\"};\n  var curPunc;\n\n  function chain(newtok, stream, state) {\n    state.tokenize.push(newtok);\n    return newtok(stream, state);\n  }\n\n  function tokenBase(stream, state) {\n    if (stream.sol() && stream.match(\"=begin\") && stream.eol()) {\n      state.tokenize.push(readBlockComment);\n      return \"comment\";\n    }\n    if (stream.eatSpace()) return null;\n    var ch = stream.next(), m;\n    if (ch == \"`\" || ch == \"'\" || ch == '\"') {\n      return chain(readQuoted(ch, \"string\", ch == '\"' || ch == \"`\"), stream, state);\n    } else if (ch == \"/\") {\n      if (regexpAhead(stream))\n        return chain(readQuoted(ch, \"string-2\", true), stream, state);\n      else\n        return \"operator\";\n    } else if (ch == \"%\") {\n      var style = \"string\", embed = true;\n      if (stream.eat(\"s\")) style = \"atom\";\n      else if (stream.eat(/[WQ]/)) style = \"string\";\n      else if (stream.eat(/[r]/)) style = \"string-2\";\n      else if (stream.eat(/[wxq]/)) { style = \"string\"; embed = false; }\n      var delim = stream.eat(/[^\\w\\s=]/);\n      if (!delim) return \"operator\";\n      if (opening.propertyIsEnumerable(delim)) delim = opening[delim];\n      return chain(readQuoted(delim, style, embed, true), stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    } else if (ch == \"<\" && (m = stream.match(/^<([-~])[\\`\\\"\\']?([a-zA-Z_?]\\w*)[\\`\\\"\\']?(?:;|$)/))) {\n      return chain(readHereDoc(m[2], m[1]), stream, state);\n    } else if (ch == \"0\") {\n      if (stream.eat(\"x\")) stream.eatWhile(/[\\da-fA-F]/);\n      else if (stream.eat(\"b\")) stream.eatWhile(/[01]/);\n      else stream.eatWhile(/[0-7]/);\n      return \"number\";\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+\\-]?[\\d_]+)?/);\n      return \"number\";\n    } else if (ch == \"?\") {\n      while (stream.match(/^\\\\[CM]-/)) {}\n      if (stream.eat(\"\\\\\")) stream.eatWhile(/\\w/);\n      else stream.next();\n      return \"string\";\n    } else if (ch == \":\") {\n      if (stream.eat(\"'\")) return chain(readQuoted(\"'\", \"atom\", false), stream, state);\n      if (stream.eat('\"')) return chain(readQuoted('\"', \"atom\", true), stream, state);\n\n      // :> :>> :< :<< are valid symbols\n      if (stream.eat(/[\\<\\>]/)) {\n        stream.eat(/[\\<\\>]/);\n        return \"atom\";\n      }\n\n      // :+ :- :/ :* :| :& :! are valid symbols\n      if (stream.eat(/[\\+\\-\\*\\/\\&\\|\\:\\!]/)) {\n        return \"atom\";\n      }\n\n      // Symbols can't start by a digit\n      if (stream.eat(/[a-zA-Z$@_\\xa1-\\uffff]/)) {\n        stream.eatWhile(/[\\w$\\xa1-\\uffff]/);\n        // Only one ? ! = is allowed and only as the last character\n        stream.eat(/[\\?\\!\\=]/);\n        return \"atom\";\n      }\n      return \"operator\";\n    } else if (ch == \"@\" && stream.match(/^@?[a-zA-Z_\\xa1-\\uffff]/)) {\n      stream.eat(\"@\");\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      return \"variable-2\";\n    } else if (ch == \"$\") {\n      if (stream.eat(/[a-zA-Z_]/)) {\n        stream.eatWhile(/[\\w]/);\n      } else if (stream.eat(/\\d/)) {\n        stream.eat(/\\d/);\n      } else {\n        stream.next(); // Must be a special global like $: or $!\n      }\n      return \"variable-3\";\n    } else if (/[a-zA-Z_\\xa1-\\uffff]/.test(ch)) {\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      stream.eat(/[\\?\\!]/);\n      if (stream.eat(\":\")) return \"atom\";\n      return \"ident\";\n    } else if (ch == \"|\" && (state.varList || state.lastTok == \"{\" || state.lastTok == \"do\")) {\n      curPunc = \"|\";\n      return null;\n    } else if (/[\\(\\)\\[\\]{}\\\\;]/.test(ch)) {\n      curPunc = ch;\n      return null;\n    } else if (ch == \"-\" && stream.eat(\">\")) {\n      return \"arrow\";\n    } else if (/[=+\\-\\/*:\\.^%<>~|]/.test(ch)) {\n      var more = stream.eatWhile(/[=+\\-\\/*:\\.^%<>~|]/);\n      if (ch == \".\" && !more) curPunc = \".\";\n      return \"operator\";\n    } else {\n      return null;\n    }\n  }\n\n  function regexpAhead(stream) {\n    var start = stream.pos, depth = 0, next, found = false, escaped = false\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (\"[{(\".indexOf(next) > -1) {\n          depth++\n        } else if (\"]})\".indexOf(next) > -1) {\n          depth--\n          if (depth < 0) break\n        } else if (next == \"/\" && depth == 0) {\n          found = true\n          break\n        }\n        escaped = next == \"\\\\\"\n      } else {\n        escaped = false\n      }\n    }\n    stream.backUp(stream.pos - start)\n    return found\n  }\n\n  function tokenBaseUntilBrace(depth) {\n    if (!depth) depth = 1;\n    return function(stream, state) {\n      if (stream.peek() == \"}\") {\n        if (depth == 1) {\n          state.tokenize.pop();\n          return state.tokenize[state.tokenize.length-1](stream, state);\n        } else {\n          state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1);\n        }\n      } else if (stream.peek() == \"{\") {\n        state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1);\n      }\n      return tokenBase(stream, state);\n    };\n  }\n  function tokenBaseOnce() {\n    var alreadyCalled = false;\n    return function(stream, state) {\n      if (alreadyCalled) {\n        state.tokenize.pop();\n        return state.tokenize[state.tokenize.length-1](stream, state);\n      }\n      alreadyCalled = true;\n      return tokenBase(stream, state);\n    };\n  }\n  function readQuoted(quote, style, embed, unescaped) {\n    return function(stream, state) {\n      var escaped = false, ch;\n\n      if (state.context.type === 'read-quoted-paused') {\n        state.context = state.context.prev;\n        stream.eat(\"}\");\n      }\n\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && (unescaped || !escaped)) {\n          state.tokenize.pop();\n          break;\n        }\n        if (embed && ch == \"#\" && !escaped) {\n          if (stream.eat(\"{\")) {\n            if (quote == \"}\") {\n              state.context = {prev: state.context, type: 'read-quoted-paused'};\n            }\n            state.tokenize.push(tokenBaseUntilBrace());\n            break;\n          } else if (/[@\\$]/.test(stream.peek())) {\n            state.tokenize.push(tokenBaseOnce());\n            break;\n          }\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      return style;\n    };\n  }\n  function readHereDoc(phrase, mayIndent) {\n    return function(stream, state) {\n      if (mayIndent) stream.eatSpace()\n      if (stream.match(phrase)) state.tokenize.pop();\n      else stream.skipToEnd();\n      return \"string\";\n    };\n  }\n  function readBlockComment(stream, state) {\n    if (stream.sol() && stream.match(\"=end\") && stream.eol())\n      state.tokenize.pop();\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: [tokenBase],\n              indented: 0,\n              context: {type: \"top\", indented: -config.indentUnit},\n              continuedLine: false,\n              lastTok: null,\n              varList: false};\n    },\n\n    token: function(stream, state) {\n      curPunc = null;\n      if (stream.sol()) state.indented = stream.indentation();\n      var style = state.tokenize[state.tokenize.length-1](stream, state), kwtype;\n      var thisTok = curPunc;\n      if (style == \"ident\") {\n        var word = stream.current();\n        style = state.lastTok == \".\" ? \"property\"\n          : keywords.propertyIsEnumerable(stream.current()) ? \"keyword\"\n          : /^[A-Z]/.test(word) ? \"tag\"\n          : (state.lastTok == \"def\" || state.lastTok == \"class\" || state.varList) ? \"def\"\n          : \"variable\";\n        if (style == \"keyword\") {\n          thisTok = word;\n          if (indentWords.propertyIsEnumerable(word)) kwtype = \"indent\";\n          else if (dedentWords.propertyIsEnumerable(word)) kwtype = \"dedent\";\n          else if ((word == \"if\" || word == \"unless\") && stream.column() == stream.indentation())\n            kwtype = \"indent\";\n          else if (word == \"do\" && state.context.indented < state.indented)\n            kwtype = \"indent\";\n        }\n      }\n      if (curPunc || (style && style != \"comment\")) state.lastTok = thisTok;\n      if (curPunc == \"|\") state.varList = !state.varList;\n\n      if (kwtype == \"indent\" || /[\\(\\[\\{]/.test(curPunc))\n        state.context = {prev: state.context, type: curPunc || style, indented: state.indented};\n      else if ((kwtype == \"dedent\" || /[\\)\\]\\}]/.test(curPunc)) && state.context.prev)\n        state.context = state.context.prev;\n\n      if (stream.eol())\n        state.continuedLine = (curPunc == \"\\\\\" || style == \"operator\");\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize[state.tokenize.length-1] != tokenBase) return CodeMirror.Pass;\n      var firstChar = textAfter && textAfter.charAt(0);\n      var ct = state.context;\n      var closed = ct.type == closing[firstChar] ||\n        ct.type == \"keyword\" && /^(?:end|until|else|elsif|when|rescue)\\b/.test(textAfter);\n      return ct.indented + (closed ? 0 : config.indentUnit) +\n        (state.continuedLine ? config.indentUnit : 0);\n    },\n\n    electricInput: /^\\s*(?:end|rescue|elsif|else|\\})$/,\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-ruby\", \"ruby\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Utility function that allows modes to be combined. The mode given\n// as the base argument takes care of most of the normal mode\n// functionality, but a second (typically simple) mode is used, which\n// can override the style of text. Both modes get to parse all of the\n// text, but when both assign a non-null style to a piece of code, the\n// overlay wins, unless the combine argument was true and not overridden,\n// or state.overlay.combineTokens was true, in which case the styles are\n// combined.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.overlayMode = function(base, overlay, combine) {\n  return {\n    startState: function() {\n      return {\n        base: CodeMirror.startState(base),\n        overlay: CodeMirror.startState(overlay),\n        basePos: 0, baseCur: null,\n        overlayPos: 0, overlayCur: null,\n        streamSeen: null\n      };\n    },\n    copyState: function(state) {\n      return {\n        base: CodeMirror.copyState(base, state.base),\n        overlay: CodeMirror.copyState(overlay, state.overlay),\n        basePos: state.basePos, baseCur: null,\n        overlayPos: state.overlayPos, overlayCur: null\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream != state.streamSeen ||\n          Math.min(state.basePos, state.overlayPos) < stream.start) {\n        state.streamSeen = stream;\n        state.basePos = state.overlayPos = stream.start;\n      }\n\n      if (stream.start == state.basePos) {\n        state.baseCur = base.token(stream, state.base);\n        state.basePos = stream.pos;\n      }\n      if (stream.start == state.overlayPos) {\n        stream.pos = stream.start;\n        state.overlayCur = overlay.token(stream, state.overlay);\n        state.overlayPos = stream.pos;\n      }\n      stream.pos = Math.min(state.basePos, state.overlayPos);\n\n      // state.overlay.combineTokens always takes precedence over combine,\n      // unless set to null\n      if (state.overlayCur == null) return state.baseCur;\n      else if (state.baseCur != null &&\n               state.overlay.combineTokens ||\n               combine && state.overlay.combineTokens == null)\n        return state.baseCur + \" \" + state.overlayCur;\n      else return state.overlayCur;\n    },\n\n    indent: base.indent && function(state, textAfter, line) {\n      return base.indent(state.base, textAfter, line);\n    },\n    electricChars: base.electricChars,\n\n    innerMode: function(state) { return {state: state.base, mode: base}; },\n\n    blankLine: function(state) {\n      var baseToken, overlayToken;\n      if (base.blankLine) baseToken = base.blankLine(state.base);\n      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);\n\n      return overlayToken == null ?\n        baseToken :\n        (combine && baseToken != null ? baseToken + \" \" + overlayToken : overlayToken);\n    }\n  };\n};\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"coffeescript\", function(conf, parserConf) {\n  var ERRORCLASS = \"error\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\n  var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n  var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\",\n                                  \"is\", \"isnt\", \"in\",\n                                  \"instanceof\", \"typeof\"]);\n  var indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\",\n                        \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\n  var commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\",\n                        \"do\", \"in\", \"of\", \"new\", \"return\", \"then\",\n                        \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n\n  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n  indentKeywords = wordRegexp(indentKeywords);\n\n\n  var stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\n  var regexPrefixes = /^(\\/{3}|\\/)/;\n  var commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\n  var constants = wordRegexp(commonConstants);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    // Handle scope changes\n    if (stream.sol()) {\n      if (state.scope.align === null) state.scope.align = false;\n      var scopeOffset = state.scope.offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n          return \"indent\";\n        } else if (lineOffset < scopeOffset) {\n          return \"dedent\";\n        }\n        return null;\n      } else {\n        if (scopeOffset > 0) {\n          dedent(stream, state);\n        }\n      }\n    }\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.peek();\n\n    // Handle docco title comment (single line)\n    if (stream.match(\"####\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    // Handle multi line comments\n    if (stream.match(\"###\")) {\n      state.tokenize = longComment;\n      return state.tokenize(stream, state);\n    }\n\n    // Single line comment\n    if (ch === \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    // Handle number literals\n    if (stream.match(/^-?[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\d+\\.\\d*/)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\.\\d+/)) {\n        floatLiteral = true;\n      }\n\n      if (floatLiteral) {\n        // prevent from getting extra . on 1..\n        if (stream.peek() == \".\"){\n          stream.backUp(1);\n        }\n        return \"number\";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^-?0x[0-9a-f]+/i)) {\n        intLiteral = true;\n      }\n      // Decimal\n      if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^-?0(?![\\dx])/i)) {\n        intLiteral = true;\n      }\n      if (intLiteral) {\n        return \"number\";\n      }\n    }\n\n    // Handle strings\n    if (stream.match(stringPrefixes)) {\n      state.tokenize = tokenFactory(stream.current(), false, \"string\");\n      return state.tokenize(stream, state);\n    }\n    // Handle regex literals\n    if (stream.match(regexPrefixes)) {\n      if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n        state.tokenize = tokenFactory(stream.current(), true, \"string-2\");\n        return state.tokenize(stream, state);\n      } else {\n        stream.backUp(1);\n      }\n    }\n\n\n\n    // Handle operators and delimiters\n    if (stream.match(operators) || stream.match(wordOperators)) {\n      return \"operator\";\n    }\n    if (stream.match(delimiters)) {\n      return \"punctuation\";\n    }\n\n    if (stream.match(constants)) {\n      return \"atom\";\n    }\n\n    if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n      return \"property\";\n    }\n\n    if (stream.match(keywords)) {\n      return \"keyword\";\n    }\n\n    if (stream.match(identifiers)) {\n      return \"variable\";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return ERRORCLASS;\n  }\n\n  function tokenFactory(delimiter, singleline, outclass) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'\"\\/\\\\]/);\n        if (stream.eat(\"\\\\\")) {\n          stream.next();\n          if (singleline && stream.eol()) {\n            return outclass;\n          }\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenBase;\n          return outclass;\n        } else {\n          stream.eat(/['\"\\/]/);\n        }\n      }\n      if (singleline) {\n        if (parserConf.singleLineStringErrors) {\n          outclass = ERRORCLASS;\n        } else {\n          state.tokenize = tokenBase;\n        }\n      }\n      return outclass;\n    };\n  }\n\n  function longComment(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^#]/);\n      if (stream.match(\"###\")) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.eatWhile(\"#\");\n    }\n    return \"comment\";\n  }\n\n  function indent(stream, state, type) {\n    type = type || \"coffee\";\n    var offset = 0, align = false, alignOffset = null;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (scope.type === \"coffee\" || scope.type == \"}\") {\n        offset = scope.offset + conf.indentUnit;\n        break;\n      }\n    }\n    if (type !== \"coffee\") {\n      align = null;\n      alignOffset = stream.column() + stream.current().length;\n    } else if (state.scope.align) {\n      state.scope.align = false;\n    }\n    state.scope = {\n      offset: offset,\n      type: type,\n      prev: state.scope,\n      align: align,\n      alignOffset: alignOffset\n    };\n  }\n\n  function dedent(stream, state) {\n    if (!state.scope.prev) return;\n    if (state.scope.type === \"coffee\") {\n      var _indent = stream.indentation();\n      var matched = false;\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (_indent === scope.offset) {\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        return true;\n      }\n      while (state.scope.prev && state.scope.offset !== _indent) {\n        state.scope = state.scope.prev;\n      }\n      return false;\n    } else {\n      state.scope = state.scope.prev;\n      return false;\n    }\n  }\n\n  function tokenLexer(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle scope changes.\n    if (current === \"return\") {\n      state.dedent = true;\n    }\n    if (((current === \"->\" || current === \"=>\") && stream.eol())\n        || style === \"indent\") {\n      indent(stream, state);\n    }\n    var delimiter_index = \"[({\".indexOf(current);\n    if (delimiter_index !== -1) {\n      indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n    }\n    if (indentKeywords.exec(current)){\n      indent(stream, state);\n    }\n    if (current == \"then\"){\n      dedent(stream, state);\n    }\n\n\n    if (style === \"dedent\") {\n      if (dedent(stream, state)) {\n        return ERRORCLASS;\n      }\n    }\n    delimiter_index = \"])}\".indexOf(current);\n    if (delimiter_index !== -1) {\n      while (state.scope.type == \"coffee\" && state.scope.prev)\n        state.scope = state.scope.prev;\n      if (state.scope.type == current)\n        state.scope = state.scope.prev;\n    }\n    if (state.dedent && stream.eol()) {\n      if (state.scope.type == \"coffee\" && state.scope.prev)\n        state.scope = state.scope.prev;\n      state.dedent = false;\n    }\n\n    return style;\n  }\n\n  var external = {\n    startState: function(basecolumn) {\n      return {\n        tokenize: tokenBase,\n        scope: {offset:basecolumn || 0, type:\"coffee\", prev: null, align: false},\n        prop: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var fillAlign = state.scope.align === null && state.scope;\n      if (fillAlign && stream.sol()) fillAlign.align = false;\n\n      var style = tokenLexer(stream, state);\n      if (style && style != \"comment\") {\n        if (fillAlign) fillAlign.align = true;\n        state.prop = style == \"punctuation\" && stream.current() == \".\"\n      }\n\n      return style;\n    },\n\n    indent: function(state, text) {\n      if (state.tokenize != tokenBase) return 0;\n      var scope = state.scope;\n      var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n      if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n      var closes = closer && scope.type === text.charAt(0);\n      if (scope.align)\n        return scope.alignOffset - (closes ? 1 : 0);\n      else\n        return (closes ? scope.prev : scope).offset;\n    },\n\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n  return external;\n});\n\n// IANA registered media type\n// https://www.iana.org/assignments/media-types/\nCodeMirror.defineMIME(\"application/vnd.coffeescript\", \"coffeescript\");\n\nCodeMirror.defineMIME(\"text/x-coffeescript\", \"coffeescript\");\nCodeMirror.defineMIME(\"text/coffeescript\", \"coffeescript\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"yaml\", function() {\n\n  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\n  var keywordRegex = new RegExp(\"\\\\b((\"+cons.join(\")|(\")+\"))$\", 'i');\n\n  return {\n    token: function(stream, state) {\n      var ch = stream.peek();\n      var esc = state.escaped;\n      state.escaped = false;\n      /* comments */\n      if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/))\n        return \"string\";\n\n      if (state.literal && stream.indentation() > state.keyCol) {\n        stream.skipToEnd(); return \"string\";\n      } else if (state.literal) { state.literal = false; }\n      if (stream.sol()) {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        /* document start */\n        if(stream.match(/---/)) { return \"def\"; }\n        /* document end */\n        if (stream.match(/\\.\\.\\./)) { return \"def\"; }\n        /* array list item */\n        if (stream.match(/\\s*-\\s+/)) { return 'meta'; }\n      }\n      /* inline pairs/lists */\n      if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n        if (ch == '{')\n          state.inlinePairs++;\n        else if (ch == '}')\n          state.inlinePairs--;\n        else if (ch == '[')\n          state.inlineList++;\n        else\n          state.inlineList--;\n        return 'meta';\n      }\n\n      /* list seperator */\n      if (state.inlineList > 0 && !esc && ch == ',') {\n        stream.next();\n        return 'meta';\n      }\n      /* pairs seperator */\n      if (state.inlinePairs > 0 && !esc && ch == ',') {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        stream.next();\n        return 'meta';\n      }\n\n      /* start of value of a pair */\n      if (state.pairStart) {\n        /* block literals */\n        if (stream.match(/^\\s*(\\||\\>)\\s*/)) { state.literal = true; return 'meta'; };\n        /* references */\n        if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) { return 'variable-2'; }\n        /* numbers */\n        if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) { return 'number'; }\n        if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) { return 'number'; }\n        /* keywords */\n        if (stream.match(keywordRegex)) { return 'keyword'; }\n      }\n\n      /* pairs (associative arrays) -> key */\n      if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^#]*?(?=\\s*:($|\\s))/)) {\n        state.pair = true;\n        state.keyCol = stream.indentation();\n        return \"atom\";\n      }\n      if (state.pair && stream.match(/^:\\s*/)) { state.pairStart = true; return 'meta'; }\n\n      /* nothing found, continue */\n      state.pairStart = false;\n      state.escaped = (ch == '\\\\');\n      stream.next();\n      return null;\n    },\n    startState: function() {\n      return {\n        pair: false,\n        pairStart: false,\n        keyCol: 0,\n        inlinePairs: 0,\n        inlineList: 0,\n        literal: false,\n        escaped: false\n      };\n    },\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-yaml\", \"yaml\");\nCodeMirror.defineMIME(\"text/yaml\", \"yaml\");\n\n});\n"],"sourceRoot":"webpack:///"}